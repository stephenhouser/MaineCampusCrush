<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- http://www.emanueleferonato.com/2011/10/07/complete-bejeweled-prototype-made-wiht-jquery/ -->
<html>
<head>
<title>Maine Campus Crush</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<link rel="apple-touch-icon" href="splash.png">
<link rel="apple-touch-startup-image" href="/startup-image.png">
<link rel="image_src" href="splash.png" />

<meta name="format-detection" content="telephone=no">

<script type="application/x-javascript"
	src="http://code.jquery.com/jquery.min.js"></script>
<script type="application/x-javascript"
	src="https://cdnjs.cloudflare.com/ajax/libs/howler/1.1.17/howler.min.js"></script>
<script type="application/x-javascript"
	src="https://cdnjs.cloudflare.com/ajax/libs/jquery.touchswipe/1.6.4/jquery.touchSwipe.js"></script>
<script type="application/x-javascript"
	src="https://cdnjs.cloudflare.com/ajax/libs/jquery.transit/0.9.12/jquery.transit.min.js"></script>

<script>
/*

FIXME: Tap on same cell twice swaps with cell on left.
	If you tap on a cell, then tap on it again (the marker) and it tries
	to swap	with the cell to the left.

TODO: Location of gamefield is absolute and very fragile
	Would be nicer to be set my HTML/CSS rather than wiggling around
	in JavaScript.

*/

/* Disabled, see below
var backgroundSound = 0;
document.addEventListener('visibilitychange', function(){
		backgroundSound.pause();
		if (!document.hidden) {
			backgroundSound.play();
		}
	},false);
*/

$(document).ready(function() {
    // These are the major configuration options
	var cols        = 6;    // Number of columns
	var rows        = 8;    // Number of rows
  	var jewelTypes  = 8;    // Number of different types of "jewels"

    // The background colors.
    // There MUST be jewelTypes of them.
  	var bgColors=new Array(
  		"rgba(0, 56, 147, 0.6)",
  		"#75B2DD",
  		"#60C659",
  		"maroon",
  		"gold",
  		"gold",
  		"green",
  		"white");

    // The "jewel" images to use.
    // There MUST be jewelTypes of them.
    var bgImages=new Array(
  		"url(usm.png)",
  		"url(umaine.png)",
  		"url(uma.png)",
  		"url(umf.png)",
  		"url(umpi.png)",
  		"url(umfk.png)",
  		"url(umm.png)",
  		"url(ums.png)"
  	);

    // Sounds, using howler.js (howlerjs.com)
	var clearSound = new Howl({urls: ['clear.wav']});
	var dropSound = new Howl({urls: ['drop.wav']});
	var selectSound = new Howl({urls: ['select.wav']});
	var errorSound = new Howl({urls: ['error.wav']});

	// Background sound.
	// Background sound is disabled because it is not working correctly.
	// Code above is designed to pause sound when the page is
	// not being displayed. It works, but only after switching away and
	// back to the page. That is, it does not pause the background sound
	// the first time you switch away, only the second, third, etc...
	/*
	backgroundSound = new Howl({
			urls: ['background.mp3'],
			autoplay: true,
			loop: true,
			volume: 0.25
		}).play();
	*/

    // Constant to represent an empty cell or invalid selection
    var empty = -1;

    var markerBorderSize = 5;

    // Get the game field somewhat where we want it.
    var gamePos = $('#gamefield').position();
	var topOffset = gamePos.top;
	var leftOffset = 7;
	/*
	var gamePos = $('#gamefield').offset();
	var topOffset = gamePos.top;
	var leftOffset = 2; //gamePos.left;
	*/

	var preferredCellSize = 60; // This is my preferred size for the jewels
	if ($(window).width() > (preferredCellSize * cols)) {
		leftOffset = ($(window).width() - (preferredCellSize * cols)) / 2;
	}

    // Compute what we will actually use for the cell size
	var cellSize = Math.floor(Math.min(preferredCellSize, (($(window).width() - (leftOffset * 2)) / cols)));

    // Use this if you want to auto-calculate the number
    // of rows that will fit on the screen rather than having it fixed (above)
	//rows = Math.floor(($(window).height() - topOffset) / cellSize)

    // Now figure out the size inside the cell -- where the jewel goes
	var gemSize = Math.floor(cellSize * 0.865);

	// And the size of the highlighted marker
	var markerSize = gemSize + 2;

    // Swipe and tap handler callbacks for interaction
    var swipeHandlers = {
        swipe:function(event, direction, distance, duration, fingerCount, fingerData) {
	        handleSwipe(event, event.changedTouches[0].target, direction);
        },
        tap:function(event, target) {
            handleTap(event, target);
        }
    }

	// Delegate .transition() calls to .animate()
	// if the browser can't do CSS transitions.
	if (!$.support.transition)
	  $.fn.transition = $.fn.animate;

  	$("#marker").css({
  		"width"         : markerSize + "px",
  		"height"        : markerSize + "px",
  		"border-radius" : "5px",
  		"border"        : markerBorderSize + "px solid white",
  		"position"      : "absolute"
  	}).hide();

    // Attach swipe and tap handlers to marker
    $("#marker").swipe(swipeHandlers);

	var selectedRow = empty;
  	var selectedCol = empty;

  	var posX;
  	var posY;

  	var jewels = new Array(); // all the jewels

  	var movingItems = 0;

  	var gameState = "pick";   // initial game state is picking a cell

    // Initialize all cells to -1 (empty)
    // TODO: Do we need to pre-initialize all the cells this way?
  	for (i = 0; i < rows; i++) {
     	jewels[i] = new Array();
     	for (j = 0; j < cols; j++) {
          	jewels[i][j] = empty;
     	}
  	}

    // Fill all cells
	for (i = 0; i < rows; i++) {
		for (j = 0; j < cols; j++) {
		    // Fill cell with a random jewel that will NOT cause a "streak" (3-match)
			do {
				jewels[i][j] = Math.floor(Math.random() * jewelTypes);
			} while (isStreak(i, j));

            // Make and add the cell to the gamefield
            var gemId = "gem_" + i +"_" + j;
			$("#gamefield").append('<div class="gem" id="' + gemId + '"></div>');

			$('#' + gemId).css({
				"top"               : (i * cellSize) + topOffset + "px",
				"left"              : (j * cellSize) + leftOffset + "px",
				"width"             : gemSize + "px",
				"height"            : gemSize + "px",
				"position"          : "absolute",
				"border"            : "2px solid white",
				"border-radius"     : "5px",
				"cursor"            : "pointer",
				"background-size"   : gemSize + "px",
				"background-image"  : bgImages[jewels[i][j]],
				"background-color"  : bgColors[jewels[i][j]]
			});

            // Attach swipe and tap handlers
			$('#' + gemId).swipe(swipeHandlers);
		}
	}

    function getPosition(element) {
        var xPosition = 0;
        var yPosition = 0;

        while (element) {
            xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
            element = element.offsetParent;
			//console.log('position(' + xPosition + ', ' + yPosition + ')');
        }

        return { x: xPosition, y: yPosition };
    }

    function getCellIndex(position) {
		cellRow = Math.floor((position.y - topOffset) / cellSize);
		cellColumn = Math.floor((position.x - leftOffset) / cellSize);

		//console.log('position(' + position.x + ', ' + position.y + ') --> ' +
		//            'cell(' + cellColumn + ', ' + cellRow + ')')

        return { col: cellColumn, row: cellRow };
    }

    function handleTap(event, target) {
        //console.log('handleTap(' + event + ', ' + target + ')');

 		if (gameState == "pick") {
 		    var position = getPosition(target);
			var selectedCell = getCellIndex(position);

            //console.log('selectedCell (' + selectedCell.col + ', ' + selectedCell.row + ')');

			$("#marker").show();
			$("#marker").css("top", position.y - markerBorderSize).css("left", position.x - markerBorderSize);

			if (selectedRow == empty) {		    // First cell selection
				selectSound.play();

				selectedRow = selectedCell.row;
				selectedCol = selectedCell.col;
			} else {			                // Second cell selection
			    posY = selectedCell.row;
			    posX = selectedCell.col;

				if ((Math.abs(selectedRow - posY) == 1 && selectedCol == posX) ||
				    (Math.abs(selectedCol - posX) == 1 && selectedRow == posY)) {
					$("#marker").hide();
					gameState = "switch";
					gemSwitch();
				} else {
					selectedRow = posY;
					selectedCol = posX;
				}
			}
		}
    }

    function handleSwipe(event, target, direction) {
        //console.log('handleSwipe(' + event + ', ' + target + ', ' + direction + ')');

		if (gameState == "pick") {
		    var pos = getPosition(target);
			posY = pos.y;
			posX = pos.x;
			$("#marker").show();
			$("#marker").css("top", posY - markerBorderSize).css("left", posX - markerBorderSize);

			selectSound.play();
			posY = selectedRow = Math.floor( (posY - topOffset) / cellSize);
			posX = selectedCol = Math.floor( (posX - leftOffset) / cellSize);

            var trySwitch = false;
            switch (direction) {
                case "up":
                    if (selectedRow > 0) {
                        posY = selectedRow - 1;
                        trySwitch = true;
                    }
                    break;
                case "down":
                    if (selectedRow < rows - 1 ) {
                        posY = selectedRow + 1;
                        trySwitch = true;
                    }
                    break;
                case "left":
                    if (selectedCol > 0) {
                        posX = selectedCol - 1;
                        trySwitch = true;
                    }
                    break;
                case "right":
                    if (selectedCol < cols - 1) {
                        posX = selectedCol + 1;
                        trySwitch = true;
                    }
                    break;
            }

            if (trySwitch) {
                if((Math.abs(selectedRow - posY) == 1 && selectedCol == posX) ||
                   (Math.abs(selectedCol - posX) == 1 && selectedRow == posY)) {
                    $("#marker").hide();
                    gameState = "switch";
                    gemSwitch();
                } else {
                    selectedRow = posY;
                    selectedCol = posX;
                }
            } else {
                // swiped out of bounds...
                errorSound.play();

                $("#marker").hide();
                posY = selectedRow = empty;
                posX = selectedCol = empty;
            }
		}
    }

	function checkMoving() {
		movingItems--;

        if (movingItems == 0) {
            switch(gameState) {
                case "revert":
                case "switch":
                    if (!isStreak(selectedRow, selectedCol) && !isStreak(posY, posX)) {
                        if (gameState != "revert") {
                            errorSound.play();
                            gameState = "revert";
                            gemSwitch();
                        } else {
                            gameState = "pick";
                            selectedRow = empty;
                        }
                    } else {
                        gameState="remove";
                        if (isStreak(selectedRow, selectedCol)) {
                            removeGems(selectedRow, selectedCol);
                        }

                        if (isStreak(posY, posX)) {
                            removeGems(posY, posX);
                        }

                    gemFade();
                }
                break;

            case "remove":
                checkFalling();
                break;

            case "refill":
                placeNewGems();
                break;
            }
        }
	}

	function placeNewGems() {
		var gemsPlaced = 0;

		for (i = 0; i < cols; i++) {
			if (jewels[0][i] == empty) {

				jewels[0][i] = Math.floor(Math.random() * jewelTypes);

          		$("#gamefield").append('<div class="gem" id="gem_0_' + i +'"></div>');

          		$("#gem_0_"+i).css({
          			"top"               : topOffset + "px",
          			"left"              : (i * cellSize) + leftOffset + "px",
          			"width"             : gemSize + "px",
          			"height"            : gemSize + "px",
          			"position"          : "absolute",
					"border"            : "2px solid white",
					"border-radius"     : "5px",
          			"cursor"            : "pointer",
					"background-size"   : gemSize + "px",
          			"background-image"  : bgImages[jewels[0][i]],
          			"background-color"  : bgColors[jewels[0][i]]
          		});

                // Attache swipe and tap handlers
                $("#gem_0_"+i).swipe(swipeHandlers);

          		gemsPlaced++;
				dropSound.play();
			}
		}

		if (gemsPlaced) {
			gameState = "remove";
			checkFalling();
		} else {
			var combo = 0
			for (i = 0; i < rows; i++) {
      			for (j = 0; j < cols; j++){
      				if (j <= (cols - 3) &&
      				    jewels[i][j] == jewels[i][j+1] && jewels[i][j] == jewels[i][j+2]) {
						combo++;
						removeGems(i, j);
					}
					if (i <= (rows-3) &&
					    jewels[i][j] == jewels[i+1][j] && jewels[i][j] == jewels[i+2][j]) {
						combo++;
						removeGems(i, j);
					}
				}
			}

			if (combo > 0){
				gameState = "remove";
				gemFade();
			} else {
				gameState = "pick";
				selectedRow = empty;
			}
		}
	}

	function checkFalling(){
		var fellDown = 0;

		for (j = 0; j < cols; j++){
			for (i = (rows-1); i > 0; i--) {
				if (jewels[i][j] == empty && jewels[i-1][j] >= 0) {
					$("#gem_"+(i-1)+"_"+j).addClass("fall").attr("id","gem_"+i+"_"+j);
					jewels[i][j] = jewels[i-1][j];
					jewels[i-1][j] = empty;
					fellDown++;
				}
			}
		}

		$.each($(".fall"), function() {
			movingItems++;
			$(this).transition({ top: "+=" + cellSize }, {
			        duration: 150,
                    complete: function() {
                        $(this).removeClass("fall");
                        checkMoving();
				}
			});
		});

		if (fellDown == 0) {
			gameState = "refill";
			movingItems = 1;
			checkMoving();
		}
	}

	function gemFade() {
		$.each($(".remove"), function() {
			clearSound.play();
			movingItems++;
			$(this)
				.transition({ scale: 1.25 }, { duration: 100 })
				.transition({ opacity:0, scale: 0.1 }, {
					duration: 150,
					complete: function() {
						$(this).remove();
						checkMoving();

						// Update score
						var score = parseInt($("#score").text());
						$("#score").text(score+10);
					}
			});
		});
	}

	function gemSwitch() {
		var yOffset = selectedRow - posY;
		var xOffset = selectedCol - posX;

		// First the animation...
		$("#gem_" + selectedRow + "_" + selectedCol).addClass("switch").attr("dir", "-1");
		$("#gem_" + posY + "_" + posX).addClass("switch").attr("dir", "1");
		$.each($(".switch"), function() {
			movingItems++;
			$(this).transition( {
                    left: "+=" + xOffset * cellSize * $(this).attr("dir"),
                    top : "+=" + yOffset * cellSize * $(this).attr("dir")
			    }, {
                    duration: 150,
                    complete: function() {
                        checkMoving();
    				}
			    }
			).removeClass("switch")
		});

        // ...then the view update
		$("#gem_" + selectedRow + "_" + selectedCol).attr("id", "temp");
		$("#gem_" + posY + "_" + posX).attr("id","gem_" + selectedRow + "_" + selectedCol);
		$("#temp").attr("id", "gem_" + posY + "_" + posX);

		// ...and here's the model switch
		var temp = jewels[selectedRow][selectedCol];
		jewels[selectedRow][selectedCol] = jewels[posY][posX];
		jewels[posY][posX] = temp;
	}

	function removeGems(row, col) {
		var gemValue = jewels[row][col];
		var tmp = row;
		$("#gem_" + row + "_" + col).addClass("remove");

		if (isVerticalStreak(row, col)){
			while (tmp > 0 && jewels[tmp-1][col] == gemValue) {
				$("#gem_" + (tmp-1) + "_" + col).addClass("remove");
				jewels[tmp-1][col] = empty;
				tmp--;
			}

			tmp = row;
			while (tmp < (rows-1) && jewels[tmp+1][col] == gemValue) {
				$("#gem_" + (tmp+1) + "_" + col).addClass("remove");
				jewels[tmp+1][col] = empty;
				tmp++;
			}
		}

		if (isHorizontalStreak(row, col)) {
			tmp = col;
			while (tmp > 0 && jewels[row][tmp-1] == gemValue){
				$("#gem_" + row + "_" + (tmp-1)).addClass("remove");
				jewels[row][tmp-1] = empty;
				tmp--;
			}

			tmp = col;
			while (tmp < (cols-1) && jewels[row][tmp+1] == gemValue) {
				$("#gem_" + row + "_" + (tmp+1)).addClass("remove");
				jewels[row][tmp+1] = empty;
				tmp++;
			}
		}

		jewels[row][col] = empty;
	}

	function isVerticalStreak(row, col) {
		var gemValue = jewels[row][col];
		var streak = 0;

		var tmp = row;
		while (tmp > 0 && jewels[tmp-1][col] == gemValue) {
			streak++;
			tmp--;
		}

		tmp = row;
		while (tmp < (rows-1) && jewels[tmp+1][col] == gemValue) {
			streak++;
			tmp++;
		}

		return streak > 1;
	}

	function isHorizontalStreak(row, col) {
		var gemValue = jewels[row][col];
		var streak = 0;

		var tmp = col;
		while (tmp > 0 && jewels[row][tmp-1] == gemValue) {
			streak++;
			tmp--;
		}

		tmp = col;
		while (tmp < (cols-1) && jewels[row][tmp+1] == gemValue) {
			streak++;
			tmp++;
		}

		return streak > 1;
	}

	function isStreak(row, col) {
	 	return isVerticalStreak(row, col) || isHorizontalStreak(row, col);
	}
});

function hideAbout() {
	$("#about").hide();
}

function showAbout() {
	$("#about").show();
}
</script>
<style>
* {
	margin: 0;
}

html, body {
	background-color: black;
	margin: 0;
	padding: 0;
}

a {
	color: white;
}

#header {
    margin: 2px;
	width: 100%;
	color: white;
}

#header .left {
    position: absolute;
    top: 10px;
    left: 5%;
    font-size: large;
 }

#header .right {
    position: absolute;
    top: 10px;
    right: 5%;
    font-size: large;
 }

#header .center {
	text-align: center;
	font-size: xx-large;
}

#gamefield {
    /*
    margin-left: auto;
    margin-right: auto;
	height: 100%;
	*/
	width: 100%;
	-webkit-user-select: none;
}

#splash {
	display: none;
}

#about {
	display: none;
	position: absolute;
	background-color: rgba(128, 128, 128, 0.95);
	color: white;
	top: 5%;
	left: 5%;
	height: 90%;
	width: 90%;
	z-index: 10;
}

</style>
</head>
<body>
	<div id="about">
		<h2>Maine Campus Crush</h2>
		<p>Score points by swapping two adjacent campus mascots to make chains
		of three or more of the same campus mascot. Swap mascots by
		clicking or tapping on them.</p>
		<br/>
		<p>The campuses and mascots of the University of Maine System:
		<ul>
			<li>UMaine - Black Bears</li>
			<li>USM - Huskies</li>
			<li>UMA - Moose</li>
			<li>UMF - Beavers</li>
			<li>UMM - Clippers</li>
			<li>UMFK - Bengals</li>
			<li>UMPI - Owls</li>
			<li>UMS - "Blue Ball"</li>
		</ul>
		</p>
		<br/>
		<p>The base code was adapted from
		<a href="http://www.emanueleferonato.com/2011/10/07/complete-bejeweled-prototype-made-wiht-jquery/">Emanuele Feronato</a>'s
		blog article on a JavaScript Bejeweled Game.</a> The mascot images were used from each
		campuses website -- taking the one that best matched the style of the game.</p>

		<br/>
		<p>-- <a href="http://about.me/stephenhouser">Stephen Houser</a></p>

		<button id="done" type="button" onClick="hideAbout();">Ok</button>
	</div>

	<div id="splash"><img src="splash.png"/>
	</div>

	<div id="header">
		<div class="left"><a href="#" type="button" onClick="showAbout();">About</a></div>
		<div class="center"><span id="score">0</span></div>
		<div class="right"><a href="#" type="button" onClick="location.reload();">Replay</a></div>
	</div>

	<div id="gamefield">
	</div>

	<div id="marker">
	</div>
</body>
</html>
